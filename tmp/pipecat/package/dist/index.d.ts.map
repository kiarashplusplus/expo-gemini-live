{"mappings":"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","sources":["client-js/rtvi/common_types.ts","client-js/rtvi/errors.ts","client-js/rtvi/messages.ts","client-js/rtvi/events.ts","client-js/rtvi/index.ts","client-js/client/decorators.ts","client-js/client/logger.ts","client-js/client/dispatcher.ts","client-js/client/rest_helpers.ts","client-js/client/transport.ts","client-js/client/utils.ts","client-js/client/client.ts","client-js/client/index.ts","client-js/index.ts"],"sourcesContent":["export type TransportState =\n  | \"disconnected\"\n  | \"initializing\"\n  | \"initialized\"\n  | \"authenticating\"\n  | \"authenticated\"\n  | \"connecting\"\n  | \"connected\"\n  | \"ready\"\n  | \"disconnecting\"\n  | \"error\";\n\nexport enum TransportStateEnum {\n  DISCONNECTED = \"disconnected\",\n  INITIALIZING = \"initializing\",\n  INITIALIZED = \"initialized\",\n  AUTHENTICATING = \"authenticating\",\n  AUTHENTICATED = \"authenticated\",\n  CONNECTING = \"connecting\",\n  CONNECTED = \"connected\",\n  READY = \"ready\",\n  DISCONNECTING = \"disconnecting\",\n  ERROR = \"error\",\n}\n\nexport type Participant = {\n  id: string;\n  name: string;\n  local: boolean;\n};\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nexport class RTVIError extends Error {\n  readonly status: number | undefined;\n\n  constructor(message?: string, status?: number | undefined) {\n    super(message);\n    this.status = status;\n  }\n}\n\nexport class ConnectionTimeoutError extends RTVIError {\n  constructor(message?: string | undefined) {\n    super(\n      message ??\n        \"Bot did not enter ready state within the specified timeout period.\"\n    );\n  }\n}\n\nexport class StartBotError extends RTVIError {\n  readonly error: string = \"invalid-request-error\";\n  constructor(message?: string | undefined, status?: number) {\n    super(\n      message ?? `Failed to connect / invalid auth bundle from base url`,\n      status ?? 500\n    );\n  }\n}\n\nexport class TransportStartError extends RTVIError {\n  constructor(message?: string | undefined) {\n    super(message ?? \"Unable to connect to transport\");\n  }\n}\n\nexport class InvalidTransportParamsError extends RTVIError {\n  constructor(message?: string | undefined) {\n    super(message ?? \"Invalid transport connection parameters\");\n  }\n}\n\nexport class BotNotReadyError extends RTVIError {\n  constructor(message?: string | undefined) {\n    super(\n      message ??\n        \"Attempt to call action on transport when not in 'ready' state.\"\n    );\n  }\n}\n\nexport class BotAlreadyStartedError extends RTVIError {\n  constructor(message?: string | undefined) {\n    super(\n      message ??\n        \"Pipecat client has already been started. Please call disconnect() before starting again.\"\n    );\n  }\n}\n\nexport class UnsupportedFeatureError extends RTVIError {\n  readonly feature: string;\n  constructor(feature: string, source?: string, message?: string) {\n    let msg = `${feature} not supported${message ? `: ${message}` : \"\"}`;\n    if (source) {\n      msg = `${source} does not support ${feature}${\n        message ? `: ${message}` : \"\"\n      }`;\n    }\n    super(msg);\n    this.feature = feature;\n  }\n}\n\nexport type DeviceArray = Array<\"cam\" | \"mic\" | \"speaker\">;\nexport type DeviceErrorType =\n  | \"in-use\"\n  | \"permissions\"\n  | \"undefined-mediadevices\"\n  | \"not-found\"\n  | \"constraints\"\n  | \"unknown\";\nexport type DeviceErrorDetails = Record<\n  string,\n  string | boolean | number | Error\n>;\n\nexport class DeviceError extends RTVIError {\n  readonly devices: DeviceArray;\n  readonly type: DeviceErrorType;\n  readonly details: DeviceErrorDetails | undefined;\n  constructor(\n    devices: DeviceArray,\n    type: DeviceErrorType,\n    message?: string,\n    details?: DeviceErrorDetails\n  ) {\n    super(message ?? `Device error for ${devices.join(\", \")}: ${type}`);\n    this.devices = devices;\n    this.type = type;\n    this.details = details;\n  }\n}\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { v4 as uuidv4 } from \"uuid\";\n\nimport {\n  name as packageName,\n  version as packageVersion,\n} from \"../package.json\";\n\nexport const RTVI_PROTOCOL_VERSION = \"1.0.0\";\nexport const RTVI_MESSAGE_LABEL = \"rtvi-ai\";\n\n/**\n * Messages the corresponding server-side client expects to receive about\n * our client-side state.\n */\nexport enum RTVIMessageType {\n  /** Outbound Messages */\n  CLIENT_READY = \"client-ready\",\n  DISCONNECT_BOT = \"disconnect-bot\",\n  // Client-to-server messages\n  CLIENT_MESSAGE = \"client-message\",\n  SEND_TEXT = \"send-text\",\n  // DEPRECATED\n  APPEND_TO_CONTEXT = \"append-to-context\",\n\n  /**\n   * Inbound Messages\n   * Messages the server-side client sends to our client-side client regarding\n   * its state or other non-service-specific messaging.\n   */\n  BOT_READY = \"bot-ready\", // Bot is connected and ready to receive messages\n  ERROR = \"error\", // Bot initialization error\n  METRICS = \"metrics\", // Bot reporting metrics\n  SERVER_MESSAGE = \"server-message\", // Custom server-to-client message\n  SERVER_RESPONSE = \"server-response\", // Server response to client message\n  ERROR_RESPONSE = \"error-response\", // Error message in response to an outbound message\n  APPEND_TO_CONTEXT_RESULT = \"append-to-context-result\", // Result of appending to context\n\n  /** Transcription Messages */\n  USER_TRANSCRIPTION = \"user-transcription\", // Local user speech to text transcription (partials and finals)\n  BOT_TRANSCRIPTION = \"bot-transcription\", // Bot full text transcription (sentence aggregated)\n  USER_STARTED_SPEAKING = \"user-started-speaking\", // User started speaking\n  USER_STOPPED_SPEAKING = \"user-stopped-speaking\", // User stopped speaking\n  BOT_STARTED_SPEAKING = \"bot-started-speaking\", // Bot started speaking\n  BOT_STOPPED_SPEAKING = \"bot-stopped-speaking\", // Bot stopped speaking\n\n  /** LLM Messages */\n  USER_LLM_TEXT = \"user-llm-text\", // Aggregated user input text which is sent to LLM\n  BOT_LLM_TEXT = \"bot-llm-text\", // Streamed token returned by the LLM\n  BOT_LLM_STARTED = \"bot-llm-started\", // Bot LLM inference starts\n  BOT_LLM_STOPPED = \"bot-llm-stopped\", // Bot LLM inference stops\n\n  // Function calling\n  LLM_FUNCTION_CALL = \"llm-function-call\", // Inbound function call from LLM\n  LLM_FUNCTION_CALL_RESULT = \"llm-function-call-result\", // Outbound result of function call\n\n  BOT_LLM_SEARCH_RESPONSE = \"bot-llm-search-response\", // Bot LLM search response\n\n  /** TTS Messages */\n  BOT_TTS_TEXT = \"bot-tts-text\", // Bot TTS text output (streamed word as it is spoken)\n  BOT_TTS_STARTED = \"bot-tts-started\", // Bot TTS response starts\n  BOT_TTS_STOPPED = \"bot-tts-stopped\", // Bot TTS response stops\n}\n\n// ----- Message Data Types\n\nexport type BotReadyData = {\n  version: string;\n  about?: unknown; // Optional about data from the bot\n};\n\ntype PlatformDetailsValue = undefined | string | number | boolean;\ntype NestedPlatformDetails =\n  | PlatformDetailsValue\n  | Record<string, PlatformDetailsValue>;\n\n// This is an interface so that different client libraries can provide their own\n// implementation of the about data, e.g., with more platform-specific details.\n// The client library should call `setAboutClient` to set this data before sending\n// the `client-ready` message.\nexport interface AboutClientData {\n  library: string; // Library name, e.g., \"@pipecat-ai/client-js\"\n  library_version?: string; // Library version, e.g., \"1.0.0\"\n  platform?: string; // Platform name, e.g., \"Android\"\n  platform_version?: string; // Platform version, e.g., \"14.0\"\n  platform_details?: Record<string, NestedPlatformDetails>; // Optional platform details, e.g., browser info\n}\n\nexport type ClientReadyData = {\n  version: string;\n  about: AboutClientData; // Information about the client library\n};\n\nexport type ErrorData = {\n  message: string;\n  fatal: boolean;\n};\n\nexport type PipecatMetricData = {\n  processor: string;\n  value: number;\n};\n\nexport type PipecatMetricsData = {\n  processing?: PipecatMetricData[];\n  ttfb?: PipecatMetricData[];\n  characters?: PipecatMetricData[];\n};\n\nexport type TranscriptData = {\n  text: string;\n  final: boolean;\n  timestamp: string;\n  user_id: string;\n};\n\nexport type BotLLMTextData = {\n  text: string;\n};\n\nexport type BotTTSTextData = {\n  text: string;\n};\n\nexport type ServerMessageData = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data: any;\n};\n\nexport type ClientMessageData = {\n  t: string;\n  d?: unknown;\n};\n\nexport type LLMSearchResult = {\n  text: string;\n  confidence: number[];\n};\n\nexport type BotLLMSearchResponseData = {\n  search_result?: string;\n  rendered_content?: string;\n  origins: LLMSearchOrigin[];\n};\n\nexport type LLMSearchOrigin = {\n  site_uri?: string;\n  site_title?: string;\n  results: LLMSearchResult[];\n};\n\nexport type LLMFunctionCallData = {\n  function_name: string;\n  tool_call_id: string;\n  args: Record<string, unknown>;\n};\n\nexport type LLMFunctionCallResult = Record<string, unknown> | string;\n\nexport type LLMFunctionCallResultResponse = {\n  function_name: string;\n  tool_call_id: string;\n  args: Record<string, unknown>;\n  result: LLMFunctionCallResult;\n};\n\nexport type SendTextOptions = {\n  run_immediately?: boolean;\n  audio_response?: boolean;\n};\n\n/** DEPRECATED */\nexport type LLMContextMessage = {\n  role: \"user\" | \"assistant\";\n  content: unknown;\n  run_immediately?: boolean;\n};\n\n/** DEPRECATED */\nexport type AppendToContextResultData = {\n  result: Record<string, unknown> | string;\n};\n\n// ----- Message Classes\n\nlet _aboutClient: AboutClientData | undefined;\nexport function setAboutClient(about: AboutClientData) {\n  // allow for partial updates to the about data\n  // this allows the client to set the about data at any time\n  // before sending the `client-ready` message and not worry about\n  // overwriting existing data\n  if (_aboutClient) {\n    _aboutClient = { ..._aboutClient, ...about };\n  } else {\n    // if no about data is set, set it to the provided value\n    _aboutClient = about;\n  }\n}\n\nexport class RTVIMessage {\n  id: string;\n  label: string = RTVI_MESSAGE_LABEL;\n  type: string;\n  data: unknown;\n\n  constructor(type: string, data: unknown, id?: string) {\n    this.type = type;\n    this.data = data;\n    this.id = id || uuidv4().slice(0, 8);\n  }\n\n  // Outbound message types\n  static clientReady(): RTVIMessage {\n    return new RTVIMessage(RTVIMessageType.CLIENT_READY, {\n      version: RTVI_PROTOCOL_VERSION,\n      about: _aboutClient || {\n        library: packageName,\n        library_version: packageVersion,\n      },\n    });\n  }\n\n  static disconnectBot(): RTVIMessage {\n    return new RTVIMessage(RTVIMessageType.DISCONNECT_BOT, {});\n  }\n\n  static error(message: string, fatal = false): RTVIMessage {\n    return new RTVIMessage(RTVIMessageType.ERROR, { message, fatal });\n  }\n}\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { Participant, TransportState } from \"./common_types\";\nimport { DeviceError } from \"./errors\";\nimport {\n  BotLLMSearchResponseData,\n  BotLLMTextData,\n  BotReadyData,\n  BotTTSTextData,\n  LLMFunctionCallData,\n  PipecatMetricsData,\n  RTVIMessage,\n  TranscriptData,\n} from \"./messages\";\n\nexport enum RTVIEvent {\n  /** local connection state events */\n  Connected = \"connected\",\n  Disconnected = \"disconnected\",\n  TransportStateChanged = \"transportStateChanged\",\n\n  /** remote connection state events */\n  BotStarted = \"botStarted\",\n  BotConnected = \"botConnected\",\n  BotReady = \"botReady\",\n  BotDisconnected = \"botDisconnected\",\n  Error = \"error\",\n\n  /** server messaging */\n  ServerMessage = \"serverMessage\",\n  ServerResponse = \"serverResponse\",\n  MessageError = \"messageError\",\n\n  /** service events */\n  Metrics = \"metrics\",\n\n  // vad events\n  BotStartedSpeaking = \"botStartedSpeaking\",\n  BotStoppedSpeaking = \"botStoppedSpeaking\",\n  UserStartedSpeaking = \"userStartedSpeaking\",\n  UserStoppedSpeaking = \"userStoppedSpeaking\",\n\n  // stt events\n  UserTranscript = \"userTranscript\",\n  BotTranscript = \"botTranscript\",\n\n  // llm events\n  BotLlmText = \"botLlmText\",\n  BotLlmStarted = \"botLlmStarted\",\n  BotLlmStopped = \"botLlmStopped\",\n\n  LLMFunctionCall = \"llmFunctionCall\",\n\n  BotLlmSearchResponse = \"botLlmSearchResponse\",\n\n  // tts events\n  BotTtsText = \"botTtsText\",\n  BotTtsStarted = \"botTtsStarted\",\n  BotTtsStopped = \"botTtsStopped\",\n\n  /** participant events */\n  ParticipantConnected = \"participantConnected\",\n  ParticipantLeft = \"participantLeft\",\n\n  /** media events */\n  TrackStarted = \"trackStarted\",\n  TrackStopped = \"trackStopped\",\n  ScreenTrackStarted = \"screenTrackStarted\",\n  ScreenTrackStopped = \"screenTrackStopped\",\n  ScreenShareError = \"screenShareError\",\n\n  LocalAudioLevel = \"localAudioLevel\",\n  RemoteAudioLevel = \"remoteAudioLevel\",\n\n  /** media device events */\n  AvailableCamsUpdated = \"availableCamsUpdated\",\n  AvailableMicsUpdated = \"availableMicsUpdated\",\n  AvailableSpeakersUpdated = \"availableSpeakersUpdated\",\n  CamUpdated = \"camUpdated\",\n  MicUpdated = \"micUpdated\",\n  SpeakerUpdated = \"speakerUpdated\",\n  DeviceError = \"deviceError\",\n}\n\nexport type RTVIEvents = Partial<{\n  /** local connection state events */\n  connected: () => void;\n  disconnected: () => void;\n  transportStateChanged: (state: TransportState) => void;\n\n  /** remote connection state events */\n  botStarted: (botResponse: unknown) => void;\n  botConnected: (participant: Participant) => void;\n  botReady: (botData: BotReadyData) => void;\n  botDisconnected: (participant: Participant) => void;\n  error: (message: RTVIMessage) => void;\n\n  /** server messaging */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  serverMessage: (data: any) => void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  serverResponse: (data: any) => void;\n  messageError: (message: RTVIMessage) => void;\n\n  /** service events */\n  metrics: (data: PipecatMetricsData) => void;\n\n  // vad events\n  botStartedSpeaking: () => void;\n  botStoppedSpeaking: () => void;\n  userStartedSpeaking: () => void;\n  userStoppedSpeaking: () => void;\n\n  // stt events\n  userTranscript: (data: TranscriptData) => void;\n  botTranscript: (data: BotLLMTextData) => void;\n\n  // llm events\n  botLlmText: (data: BotLLMTextData) => void;\n  botLlmStarted: () => void;\n  botLlmStopped: () => void;\n\n  llmFunctionCall: (func: LLMFunctionCallData) => void;\n\n  botLlmSearchResponse: (data: BotLLMSearchResponseData) => void;\n\n  // tts events\n  botTtsText: (data: BotTTSTextData) => void;\n  botTtsStarted: () => void;\n  botTtsStopped: () => void;\n\n  /** participant events */\n  participantConnected: (participant: Participant) => void;\n  participantLeft: (participant: Participant) => void;\n\n  /** media events */\n  trackStarted: (track: MediaStreamTrack, participant?: Participant) => void;\n  trackStopped: (track: MediaStreamTrack, participant?: Participant) => void;\n  screenTrackStarted: (track: MediaStreamTrack, p?: Participant) => void;\n  screenTrackStopped: (track: MediaStreamTrack, p?: Participant) => void;\n  screenShareError: (errorMessage: string) => void;\n\n  localAudioLevel: (level: number) => void;\n  remoteAudioLevel: (level: number, p: Participant) => void;\n\n  /** media device events */\n  availableCamsUpdated: (cams: MediaDeviceInfo[]) => void;\n  availableMicsUpdated: (mics: MediaDeviceInfo[]) => void;\n  availableSpeakersUpdated: (speakers: MediaDeviceInfo[]) => void;\n  camUpdated: (cam: MediaDeviceInfo) => void;\n  micUpdated: (mic: MediaDeviceInfo) => void;\n  speakerUpdated: (speaker: MediaDeviceInfo) => void;\n  deviceError: (error: DeviceError) => void;\n}>;\n\nexport type RTVIEventHandler<E extends RTVIEvent> = E extends keyof RTVIEvents\n  ? RTVIEvents[E]\n  : never;\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nexport * from \"./common_types\";\nexport * from \"./errors\";\nexport * from \"./events\";\nexport * from \"./messages\";\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { BotAlreadyStartedError, BotNotReadyError } from \"../rtvi\";\nimport { PipecatClient } from \".\";\n\nexport function transportReady<T extends PipecatClient>(\n  _target: T,\n  propertyKey: string | symbol,\n  descriptor: PropertyDescriptor\n): PropertyDescriptor | void {\n  const originalMethod = descriptor.value;\n\n  descriptor.value = function (this: T, ...args: unknown[]) {\n    if (this.state === \"ready\") {\n      return originalMethod.apply(this, args);\n    } else {\n      throw new BotNotReadyError(\n        `Attempt to call ${propertyKey.toString()} when transport not in ready state. Await connect() first.`\n      );\n    }\n  };\n\n  return descriptor;\n}\n\nexport function transportAlreadyStarted<T extends PipecatClient>(\n  _target: T,\n  propertyKey: string | symbol,\n  descriptor: PropertyDescriptor\n): PropertyDescriptor | void {\n  const originalMethod = descriptor.value;\n\n  const states = [\"authenticating\", \"connecting\", \"connected\", \"ready\"];\n\n  descriptor.value = function (this: T, ...args: unknown[]) {\n    if (states.includes(this.state)) {\n      throw new BotAlreadyStartedError(\n        `Attempt to call ${propertyKey.toString()} when client already started. Please call disconnect() before starting again.`\n      );\n    } else {\n      return originalMethod.apply(this, args);\n    }\n  };\n\n  return descriptor;\n}\n\nexport function transportInState<T extends PipecatClient>(states: string[]) {\n  return function (\n    _target: T,\n    propertyKey: string | symbol,\n    descriptor: PropertyDescriptor\n  ): PropertyDescriptor | void {\n    const originalMethod = descriptor.value;\n\n    descriptor.get = function (this: T, ...args: unknown[]) {\n      if (states.includes(this.state)) {\n        return originalMethod.apply(this, args);\n      } else {\n        throw new BotNotReadyError(\n          `Attempt to call ${propertyKey.toString()} when transport not in ${states}.`\n        );\n      }\n    };\n\n    return descriptor;\n  };\n}\n\nexport function getIfTransportInState<T extends PipecatClient>(\n  ...states: string[]\n) {\n  states = [\"ready\", ...states];\n\n  return function (\n    _target: T,\n    propertyKey: string | symbol,\n    descriptor: PropertyDescriptor\n  ): PropertyDescriptor | void {\n    const originalGetter = descriptor.get;\n\n    descriptor.get = function (this: T) {\n      if (states.includes(this.state)) {\n        return originalGetter?.apply(this);\n      } else {\n        throw new BotNotReadyError(\n          `Attempt to call ${propertyKey.toString()} when transport not in ${states}. Await connect() first.`\n        );\n      }\n    };\n\n    return descriptor;\n  };\n}\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nexport enum LogLevel {\n  NONE = 0,\n  ERROR = 1,\n  WARN = 2,\n  INFO = 3,\n  DEBUG = 4,\n}\n\nclass Logger {\n  private static instance: Logger;\n  private level: LogLevel = LogLevel.DEBUG;\n\n  private constructor() {}\n\n  static getInstance(): Logger {\n    if (!Logger.instance) {\n      Logger.instance = new Logger();\n    }\n    return Logger.instance;\n  }\n\n  setLevel(level: LogLevel) {\n    this.level = level;\n  }\n\n  debug(...args: unknown[]) {\n    if (this.level >= LogLevel.DEBUG) {\n      console.debug(...args);\n    }\n  }\n\n  info(...args: unknown[]) {\n    if (this.level >= LogLevel.INFO) {\n      console.info(...args);\n    }\n  }\n\n  warn(...args: unknown[]) {\n    if (this.level >= LogLevel.WARN) {\n      console.warn(...args);\n    }\n  }\n\n  error(...args: unknown[]) {\n    if (this.level >= LogLevel.ERROR) {\n      console.error(...args);\n    }\n  }\n}\n\nexport const logger = Logger.getInstance();\n\nexport type ILogger = Logger;\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { ClientMessageData, RTVIMessage, RTVIMessageType } from \"../rtvi\";\nimport { logger } from \"./logger\";\n\ninterface QueuedRTVIMessage {\n  message: RTVIMessage;\n  timestamp: number;\n  timeout: number;\n  resolve: (value: unknown) => void;\n  reject: (reason?: unknown) => void;\n}\n\nexport class MessageDispatcher {\n  protected _sendMethod: (message: RTVIMessage) => void;\n  protected _queue = new Array<QueuedRTVIMessage>();\n  protected _gcInterval: ReturnType<typeof setInterval> | undefined = undefined;\n\n  constructor(sendMethod: (message: RTVIMessage) => void) {\n    this._queue = [];\n    this._sendMethod = sendMethod;\n  }\n\n  public disconnect() {\n    this.clearQueue();\n    clearInterval(this._gcInterval);\n    this._gcInterval = undefined;\n  }\n\n  public dispatch(\n    message_data: unknown,\n    type = RTVIMessageType.CLIENT_MESSAGE,\n    timeout = 10000\n  ): Promise<RTVIMessage> {\n    if (!this._gcInterval) {\n      // start garbage collection if not already running\n      this._gcInterval = setInterval(() => {\n        this._gc();\n      }, 2000); // Run garbage collection every 2 seconds\n    }\n\n    const message = new RTVIMessage(type, message_data);\n    const promise = new Promise((resolve, reject) => {\n      this._queue.push({\n        message,\n        timestamp: Date.now(),\n        timeout,\n        resolve,\n        reject,\n      });\n    });\n\n    logger.debug(\"[MessageDispatcher] dispatch\", message);\n\n    try {\n      this._sendMethod(message);\n    } catch (e) {\n      logger.error(\"[MessageDispatcher] Error sending message\", e);\n      return Promise.reject(e);\n    }\n\n    this._gc();\n\n    return promise as Promise<RTVIMessage>;\n  }\n\n  public clearQueue() {\n    this._queue = [];\n  }\n\n  private _resolveReject(\n    message: RTVIMessage,\n    resolve: boolean = true\n  ): RTVIMessage {\n    const queuedMessage = this._queue.find(\n      (msg) => msg.message.id === message.id\n    );\n\n    if (queuedMessage) {\n      if (resolve) {\n        logger.debug(\"[MessageDispatcher] Resolve\", message);\n        queuedMessage.resolve(message as RTVIMessage);\n      } else {\n        logger.debug(\"[MessageDispatcher] Reject\", message);\n        queuedMessage.reject(message as RTVIMessage);\n      }\n      // Remove message from queue\n      this._queue = this._queue.filter((msg) => msg.message.id !== message.id);\n      logger.debug(\"[MessageDispatcher] Queue\", this._queue);\n    }\n\n    return message;\n  }\n\n  public resolve(message: RTVIMessage): RTVIMessage {\n    return this._resolveReject(message, true);\n  }\n\n  public reject(message: RTVIMessage): RTVIMessage {\n    return this._resolveReject(message, false);\n  }\n\n  protected _gc() {\n    const expired: QueuedRTVIMessage[] = [];\n    this._queue = this._queue.filter((msg) => {\n      const isValid = Date.now() - msg.timestamp < msg.timeout;\n      if (!isValid) {\n        expired.push(msg);\n      }\n      return isValid;\n    });\n\n    expired.forEach((msg) => {\n      if (msg.message.type === RTVIMessageType.CLIENT_MESSAGE) {\n        msg.reject(\n          new RTVIMessage(RTVIMessageType.ERROR_RESPONSE, {\n            error: \"Timed out waiting for response\",\n            msgType: (msg.message.data as ClientMessageData).t,\n            data: (msg.message.data as ClientMessageData).d,\n            fatal: false,\n          })\n        );\n      }\n    });\n    logger.debug(\"[MessageDispatcher] GC\", this._queue);\n  }\n}\n","import { logger } from \"./logger\";\n\ntype Serializable =\n  | string\n  | number\n  | boolean\n  | null\n  | Serializable[]\n  | { [key: number | string]: Serializable };\n\nexport interface APIRequest {\n  endpoint: string | URL | globalThis.Request;\n  headers?: Headers;\n  requestData?: Serializable;\n  timeout?: number;\n}\n\n/**\n * @deprecated Use APIRequest instead\n */\nexport type ConnectionEndpoint = APIRequest;\n\nexport function isAPIRequest(value: unknown): boolean {\n  if (\n    typeof value === \"object\" &&\n    value !== null &&\n    Object.keys(value).includes(\"endpoint\")\n  ) {\n    const endpoint = (value as APIRequest)[\"endpoint\"];\n    return (\n      typeof endpoint === \"string\" ||\n      endpoint instanceof URL ||\n      (typeof Request !== \"undefined\" && endpoint instanceof Request)\n    );\n  }\n  return false;\n}\n\nexport async function makeRequest(\n  cxnOpts: APIRequest,\n  abortController?: AbortController\n): Promise<unknown> {\n  if (!abortController) {\n    abortController = new AbortController();\n  }\n  let handshakeTimeout: ReturnType<typeof setTimeout> | undefined;\n\n  return new Promise((resolve, reject) => {\n    (async () => {\n      if (cxnOpts.timeout) {\n        handshakeTimeout = setTimeout(async () => {\n          abortController.abort();\n          reject(new Error(\"Timed out\"));\n        }, cxnOpts.timeout);\n      }\n\n      logger.debug(`[Pipecat Client] Fetching from ${cxnOpts.endpoint}`);\n      fetch(cxnOpts.endpoint, {\n        method: \"POST\",\n        mode: \"cors\",\n        headers: new Headers({\n          \"Content-Type\": \"application/json\",\n          ...Object.fromEntries((cxnOpts.headers ?? new Headers()).entries()),\n        }),\n        body: JSON.stringify(cxnOpts.requestData),\n        signal: abortController?.signal,\n      })\n        .then((res) => {\n          logger.debug(\n            `[Pipecat Client] Received response from ${cxnOpts.endpoint}`,\n            res\n          );\n          if (!res.ok) {\n            reject(res);\n          }\n          res.json().then((data) => resolve(data));\n        })\n        .catch((err) => {\n          logger.error(`[Pipecat Client] Error fetching: ${err}`);\n          reject(err);\n        })\n        .finally(() => {\n          if (handshakeTimeout) {\n            clearTimeout(handshakeTimeout);\n          }\n        });\n    })();\n  });\n}\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport { RTVIError, RTVIMessage, TransportState } from \"../rtvi\";\nimport { PipecatClientOptions, RTVIEventCallbacks } from \"./client\";\nimport { APIRequest } from \"./rest_helpers.ts\";\n\nexport type Tracks = {\n  local: {\n    audio?: MediaStreamTrack;\n    video?: MediaStreamTrack;\n    screenAudio?: MediaStreamTrack;\n    screenVideo?: MediaStreamTrack;\n  };\n  bot?: {\n    audio?: MediaStreamTrack;\n    screenAudio?: undefined;\n    screenVideo?: undefined;\n    video?: MediaStreamTrack;\n  };\n};\n\nexport type TransportConnectionParams = unknown;\n\nexport abstract class Transport {\n  protected declare _options: PipecatClientOptions;\n  protected declare _onMessage: (ev: RTVIMessage) => void;\n  protected declare _callbacks: RTVIEventCallbacks;\n  protected declare _abortController: AbortController | undefined;\n  protected _state: TransportState = \"disconnected\";\n  protected _startBotParams: APIRequest | undefined;\n\n  constructor() {}\n\n  /** called from PipecatClient constructor to wire up callbacks */\n  abstract initialize(\n    options: PipecatClientOptions,\n    messageHandler: (ev: RTVIMessage) => void\n  ): void;\n\n  /**\n   * This method is intended to initialize cam/mic devices. It is wrapped\n   * by PipecatClient.initDevices and should not be called directly. It is also\n   * called as part of PipecatClient.connect if it has not already called.\n   */\n  abstract initDevices(): Promise<void>;\n\n  /**\n   * Establishes a connection with the remote server. This is the main entry\n   * point for the transport to start sending and receiving media and messages.\n   * This is called from PipecatClient.connect() and should not be called directly.\n   * @param connectParams - This type will ultimately be defned by the transport\n   * implementation. It is used to pass connection parameters to the transport.\n   */\n  connect(connectParams?: TransportConnectionParams): Promise<void> {\n    this._abortController = new AbortController();\n    let validatedParams = connectParams;\n    try {\n      validatedParams = this._validateConnectionParams(connectParams);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      throw new RTVIError(\n        `Invalid connection params: ${e.message}. Please check your connection params and try again.`\n      );\n    }\n    return this._connect(validatedParams);\n  }\n\n  /**\n   * Allow the transports to determine how the bot was started.\n   */\n  get startBotParams(): APIRequest | undefined {\n    return this._startBotParams;\n  }\n\n  /**\n   * Set the parameters used to start the bot.\n   * @param startBotParams\n   */\n  set startBotParams(startBotParams: APIRequest) {\n    this._startBotParams = startBotParams;\n  }\n\n  abstract _validateConnectionParams(connectParams?: unknown): unknown;\n\n  abstract _connect(connectParams?: TransportConnectionParams): Promise<void>;\n  /**\n   * Disconnects the transport from the remote server. This is called from\n   * PipecatClient.disconnect() and should not be called directly.\n   */\n  disconnect(): Promise<void> {\n    if (this._abortController) {\n      this._abortController.abort();\n    }\n    return this._disconnect();\n  }\n  abstract _disconnect(): Promise<void>;\n  abstract sendReadyMessage(): void;\n\n  abstract get state(): TransportState;\n  abstract set state(state: TransportState);\n\n  abstract getAllMics(): Promise<MediaDeviceInfo[]>;\n  abstract getAllCams(): Promise<MediaDeviceInfo[]>;\n  abstract getAllSpeakers(): Promise<MediaDeviceInfo[]>;\n\n  abstract updateMic(micId: string): void;\n  abstract updateCam(camId: string): void;\n  abstract updateSpeaker(speakerId: string): void;\n\n  abstract get selectedMic(): MediaDeviceInfo | Record<string, never>;\n  abstract get selectedCam(): MediaDeviceInfo | Record<string, never>;\n  abstract get selectedSpeaker(): MediaDeviceInfo | Record<string, never>;\n\n  abstract enableMic(enable: boolean): void;\n  abstract enableCam(enable: boolean): void;\n  abstract enableScreenShare(enable: boolean): void;\n  abstract get isCamEnabled(): boolean;\n  abstract get isMicEnabled(): boolean;\n  abstract get isSharingScreen(): boolean;\n\n  abstract sendMessage(message: RTVIMessage): void;\n\n  abstract tracks(): Tracks;\n}\n\nexport class TransportWrapper {\n  private _transport: Transport;\n  private _proxy: Transport;\n\n  constructor(transport: Transport) {\n    this._transport = transport;\n    this._proxy = new Proxy(this._transport, {\n      get: (target, prop, receiver) => {\n        if (typeof target[prop as keyof Transport] === \"function\") {\n          let errMsg;\n          switch (String(prop)) {\n            // Disable methods that modify the lifecycle of the call. These operations\n            // should be performed via the Pipecat client in order to keep state in sync.\n            case \"initialize\":\n              errMsg = `Direct calls to initialize() are disabled and used internally by the PipecatClient.`;\n              break;\n            case \"initDevices\":\n              errMsg = `Direct calls to initDevices() are disabled. Please use the PipecatClient.initDevices() wrapper or let PipecatClient.connect() call it for you.`;\n              break;\n            case \"sendReadyMessage\":\n              errMsg = `Direct calls to sendReadyMessage() are disabled and used internally by the PipecatClient.`;\n              break;\n            case \"connect\":\n              errMsg = `Direct calls to connect() are disabled. Please use the PipecatClient.connect() wrapper.`;\n              break;\n            case \"disconnect\":\n              errMsg = `Direct calls to disconnect() are disabled. Please use the PipecatClient.disconnect() wrapper.`;\n              break;\n          }\n          if (errMsg) {\n            return () => {\n              throw new Error(errMsg);\n            };\n          }\n          // Forward other method calls\n          return (...args: unknown[]) => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n            return (target[prop as keyof Transport] as Function)(...args);\n          };\n        }\n        // Forward property access\n        return Reflect.get(target, prop, receiver);\n      },\n    });\n  }\n\n  get proxy(): Transport {\n    return this._proxy;\n  }\n}\n","import Bowser from \"bowser\";\n\nimport {\n  name as packageName,\n  version as packageVersion,\n} from \"../package.json\";\nimport { AboutClientData } from \"../rtvi/messages\";\n\ninterface JSAboutClientData extends AboutClientData {\n  platform_details: {\n    browser?: string;\n    browser_version?: string;\n    platform_type?: string;\n    engine?: string;\n    device_memory?: number;\n    language?: string;\n    connection?: {\n      effectiveType?: string;\n      downlink?: number;\n    };\n  };\n}\n\nexport function learnAboutClient() {\n  let about: JSAboutClientData = {\n    library: packageName,\n    library_version: packageVersion,\n    platform_details: {},\n  };\n  // This uses legacy browser user agent parsing, which we still fall\n  // back to if the User Agent Hints API is not available\n  let navAgentInfo = null;\n  if (window?.navigator?.userAgent) {\n    try {\n      navAgentInfo = Bowser.parse(window.navigator.userAgent);\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    } catch (_) {\n      // void\n    }\n  }\n\n  if (navAgentInfo?.browser?.name) {\n    about.platform_details.browser = navAgentInfo.browser.name;\n  }\n  if (\n    navAgentInfo?.browser?.name === \"Safari\" &&\n    !navAgentInfo.browser.version\n  ) {\n    about.platform_details.browser_version = \"Web View\";\n  } else if (navAgentInfo?.browser?.version) {\n    about.platform_details.browser_version = navAgentInfo.browser.version;\n  }\n\n  if (navAgentInfo?.platform?.type) {\n    about.platform_details.platform_type = navAgentInfo.platform.type;\n  }\n\n  if (navAgentInfo?.engine?.name) {\n    about.platform_details.engine = navAgentInfo.engine.name;\n  }\n\n  if (navAgentInfo?.os) {\n    about.platform = navAgentInfo.os.name;\n    about.platform_version = navAgentInfo.os.version;\n  }\n  return about;\n}\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nimport EventEmitter from \"events\";\nimport TypedEmitter from \"typed-emitter\";\n\nimport packageJson from \"../package.json\";\nimport {\n  BotLLMSearchResponseData,\n  BotLLMTextData,\n  BotReadyData,\n  BotTTSTextData,\n  ClientMessageData,\n  ErrorData,\n  LLMContextMessage,\n  LLMFunctionCallData,\n  LLMFunctionCallResult,\n  Participant,\n  PipecatMetricsData,\n  RTVIEvent,\n  RTVIEvents,\n  RTVIMessage,\n  RTVIMessageType,\n  SendTextOptions,\n  setAboutClient,\n  TranscriptData,\n  TransportState,\n} from \"../rtvi\";\nimport * as RTVIErrors from \"../rtvi/errors\";\nimport { transportAlreadyStarted, transportReady } from \"./decorators\";\nimport { MessageDispatcher } from \"./dispatcher\";\nimport { logger, LogLevel } from \"./logger\";\nimport {\n  APIRequest,\n  ConnectionEndpoint,\n  isAPIRequest,\n  makeRequest,\n} from \"./rest_helpers\";\nimport {\n  Tracks,\n  Transport,\n  TransportConnectionParams,\n  TransportWrapper,\n} from \"./transport\";\nimport { learnAboutClient } from \"./utils\";\n\nexport type FunctionCallParams = {\n  functionName: string;\n  arguments: Record<string, unknown>;\n};\n\nexport type FunctionCallCallback = (\n  fn: FunctionCallParams\n) => Promise<LLMFunctionCallResult | void>;\n\nexport type RTVIEventCallbacks = Partial<{\n  onConnected: () => void;\n  onDisconnected: () => void;\n  onError: (message: RTVIMessage) => void;\n  onTransportStateChanged: (state: TransportState) => void;\n\n  onBotStarted: (botResponse: unknown) => void;\n  onBotConnected: (participant: Participant) => void;\n  onBotReady: (botReadyData: BotReadyData) => void;\n  onBotDisconnected: (participant: Participant) => void;\n  onMetrics: (data: PipecatMetricsData) => void;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  onServerMessage: (data: any) => void;\n  onMessageError: (message: RTVIMessage) => void;\n\n  onParticipantJoined: (participant: Participant) => void;\n  onParticipantLeft: (participant: Participant) => void;\n\n  onAvailableCamsUpdated: (cams: MediaDeviceInfo[]) => void;\n  onAvailableMicsUpdated: (mics: MediaDeviceInfo[]) => void;\n  onAvailableSpeakersUpdated: (speakers: MediaDeviceInfo[]) => void;\n  onCamUpdated: (cam: MediaDeviceInfo) => void;\n  onMicUpdated: (mic: MediaDeviceInfo) => void;\n  onSpeakerUpdated: (speaker: MediaDeviceInfo) => void;\n  onDeviceError: (error: RTVIErrors.DeviceError) => void;\n  onTrackStarted: (track: MediaStreamTrack, participant?: Participant) => void;\n  onTrackStopped: (track: MediaStreamTrack, participant?: Participant) => void;\n  onScreenTrackStarted: (\n    track: MediaStreamTrack,\n    participant?: Participant\n  ) => void;\n  onScreenTrackStopped: (\n    track: MediaStreamTrack,\n    participant?: Participant\n  ) => void;\n  onScreenShareError: (errorMessage: string) => void;\n  onLocalAudioLevel: (level: number) => void;\n  onRemoteAudioLevel: (level: number, participant: Participant) => void;\n\n  onBotStartedSpeaking: () => void;\n  onBotStoppedSpeaking: () => void;\n  onUserStartedSpeaking: () => void;\n  onUserStoppedSpeaking: () => void;\n  onUserTranscript: (data: TranscriptData) => void;\n  onBotTranscript: (data: BotLLMTextData) => void;\n\n  onBotLlmText: (data: BotLLMTextData) => void;\n  onBotLlmStarted: () => void;\n  onBotLlmStopped: () => void;\n  onBotTtsText: (data: BotTTSTextData) => void;\n  onBotTtsStarted: () => void;\n  onBotTtsStopped: () => void;\n\n  onLLMFunctionCall: (data: LLMFunctionCallData) => void;\n  onBotLlmSearchResponse: (data: BotLLMSearchResponseData) => void;\n}>;\n\nexport interface PipecatClientOptions {\n  /**\n   * Transport class for media streaming\n   */\n  transport: Transport;\n\n  /**\n   * Optional callback methods for RTVI events\n   */\n  callbacks?: RTVIEventCallbacks;\n\n  /**\n   * Enable user mic input\n   *\n   * Default to true\n   */\n  enableMic?: boolean;\n\n  /**\n   * Enable user cam input\n   *\n   * Default to false\n   */\n  enableCam?: boolean;\n\n  /**\n   * Enable screen sharing\n   *\n   * Default to false\n   */\n  enableScreenShare?: boolean;\n}\n\nabstract class RTVIEventEmitter extends (EventEmitter as unknown as new () => TypedEmitter<RTVIEvents>) {}\n\nexport class PipecatClient extends RTVIEventEmitter {\n  protected _options: PipecatClientOptions;\n  private _connectResolve: ((value: BotReadyData) => void) | undefined;\n  protected _transport: Transport;\n  protected _transportWrapper: TransportWrapper;\n  protected declare _messageDispatcher: MessageDispatcher;\n  protected _functionCallCallbacks: Record<string, FunctionCallCallback> = {};\n  protected _abortController: AbortController | undefined;\n\n  constructor(options: PipecatClientOptions) {\n    super();\n\n    setAboutClient(learnAboutClient());\n\n    this._transport = options.transport;\n    this._transportWrapper = new TransportWrapper(this._transport);\n\n    // Wrap transport callbacks with event triggers\n    // This allows for either functional callbacks or .on / .off event listeners\n    const wrappedCallbacks: RTVIEventCallbacks = {\n      ...options.callbacks,\n      onMessageError: (message: RTVIMessage) => {\n        options?.callbacks?.onMessageError?.(message);\n        this.emit(RTVIEvent.MessageError, message);\n      },\n      onError: (message: RTVIMessage) => {\n        options?.callbacks?.onError?.(message);\n        try {\n          this.emit(RTVIEvent.Error, message);\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        } catch (e) {\n          logger.debug(\"Could not emit error\", message);\n        }\n        const data = message.data as ErrorData;\n        if (data?.fatal) {\n          logger.error(\"Fatal error reported. Disconnecting...\");\n          this.disconnect();\n        }\n      },\n      onConnected: () => {\n        options?.callbacks?.onConnected?.();\n        this.emit(RTVIEvent.Connected);\n      },\n      onDisconnected: () => {\n        options?.callbacks?.onDisconnected?.();\n        this.emit(RTVIEvent.Disconnected);\n      },\n      onTransportStateChanged: (state: TransportState) => {\n        options?.callbacks?.onTransportStateChanged?.(state);\n        this.emit(RTVIEvent.TransportStateChanged, state);\n      },\n      onParticipantJoined: (p) => {\n        options?.callbacks?.onParticipantJoined?.(p);\n        this.emit(RTVIEvent.ParticipantConnected, p);\n      },\n      onParticipantLeft: (p) => {\n        options?.callbacks?.onParticipantLeft?.(p);\n        this.emit(RTVIEvent.ParticipantLeft, p);\n      },\n      onTrackStarted: (track, p) => {\n        options?.callbacks?.onTrackStarted?.(track, p);\n        this.emit(RTVIEvent.TrackStarted, track, p);\n      },\n      onTrackStopped: (track, p) => {\n        options?.callbacks?.onTrackStopped?.(track, p);\n        this.emit(RTVIEvent.TrackStopped, track, p);\n      },\n      onScreenTrackStarted: (track, p) => {\n        options?.callbacks?.onScreenTrackStarted?.(track, p);\n        this.emit(RTVIEvent.ScreenTrackStarted, track, p);\n      },\n      onScreenTrackStopped: (track, p) => {\n        options?.callbacks?.onScreenTrackStopped?.(track, p);\n        this.emit(RTVIEvent.ScreenTrackStopped, track, p);\n      },\n      onScreenShareError: (errorMessage) => {\n        options?.callbacks?.onScreenShareError?.(errorMessage);\n        this.emit(RTVIEvent.ScreenShareError, errorMessage);\n      },\n      onAvailableCamsUpdated: (cams) => {\n        options?.callbacks?.onAvailableCamsUpdated?.(cams);\n        this.emit(RTVIEvent.AvailableCamsUpdated, cams);\n      },\n      onAvailableMicsUpdated: (mics) => {\n        options?.callbacks?.onAvailableMicsUpdated?.(mics);\n        this.emit(RTVIEvent.AvailableMicsUpdated, mics);\n      },\n      onAvailableSpeakersUpdated: (speakers) => {\n        options?.callbacks?.onAvailableSpeakersUpdated?.(speakers);\n        this.emit(RTVIEvent.AvailableSpeakersUpdated, speakers);\n      },\n      onCamUpdated: (cam) => {\n        options?.callbacks?.onCamUpdated?.(cam);\n        this.emit(RTVIEvent.CamUpdated, cam);\n      },\n      onMicUpdated: (mic) => {\n        options?.callbacks?.onMicUpdated?.(mic);\n        this.emit(RTVIEvent.MicUpdated, mic);\n      },\n      onSpeakerUpdated: (speaker) => {\n        options?.callbacks?.onSpeakerUpdated?.(speaker);\n        this.emit(RTVIEvent.SpeakerUpdated, speaker);\n      },\n      onDeviceError: (error) => {\n        options?.callbacks?.onDeviceError?.(error);\n        this.emit(RTVIEvent.DeviceError, error);\n      },\n      onBotStarted: (botResponse: unknown) => {\n        options?.callbacks?.onBotStarted?.(botResponse);\n        this.emit(RTVIEvent.BotStarted, botResponse);\n      },\n      onBotConnected: (p) => {\n        options?.callbacks?.onBotConnected?.(p);\n        this.emit(RTVIEvent.BotConnected, p);\n      },\n      onBotReady: (botReadyData: BotReadyData) => {\n        options?.callbacks?.onBotReady?.(botReadyData);\n        this.emit(RTVIEvent.BotReady, botReadyData);\n      },\n      onBotDisconnected: (p) => {\n        options?.callbacks?.onBotDisconnected?.(p);\n        this.emit(RTVIEvent.BotDisconnected, p);\n      },\n      onBotStartedSpeaking: () => {\n        options?.callbacks?.onBotStartedSpeaking?.();\n        this.emit(RTVIEvent.BotStartedSpeaking);\n      },\n      onBotStoppedSpeaking: () => {\n        options?.callbacks?.onBotStoppedSpeaking?.();\n        this.emit(RTVIEvent.BotStoppedSpeaking);\n      },\n      onRemoteAudioLevel: (level, p) => {\n        options?.callbacks?.onRemoteAudioLevel?.(level, p);\n        this.emit(RTVIEvent.RemoteAudioLevel, level, p);\n      },\n      onUserStartedSpeaking: () => {\n        options?.callbacks?.onUserStartedSpeaking?.();\n        this.emit(RTVIEvent.UserStartedSpeaking);\n      },\n      onUserStoppedSpeaking: () => {\n        options?.callbacks?.onUserStoppedSpeaking?.();\n        this.emit(RTVIEvent.UserStoppedSpeaking);\n      },\n      onLocalAudioLevel: (level) => {\n        options?.callbacks?.onLocalAudioLevel?.(level);\n        this.emit(RTVIEvent.LocalAudioLevel, level);\n      },\n      onUserTranscript: (data) => {\n        options?.callbacks?.onUserTranscript?.(data);\n        this.emit(RTVIEvent.UserTranscript, data);\n      },\n      onBotTranscript: (text) => {\n        options?.callbacks?.onBotTranscript?.(text);\n        this.emit(RTVIEvent.BotTranscript, text);\n      },\n      onBotLlmText: (text) => {\n        options?.callbacks?.onBotLlmText?.(text);\n        this.emit(RTVIEvent.BotLlmText, text);\n      },\n      onBotLlmStarted: () => {\n        options?.callbacks?.onBotLlmStarted?.();\n        this.emit(RTVIEvent.BotLlmStarted);\n      },\n      onBotLlmStopped: () => {\n        options?.callbacks?.onBotLlmStopped?.();\n        this.emit(RTVIEvent.BotLlmStopped);\n      },\n      onBotTtsText: (text) => {\n        options?.callbacks?.onBotTtsText?.(text);\n        this.emit(RTVIEvent.BotTtsText, text);\n      },\n      onBotTtsStarted: () => {\n        options?.callbacks?.onBotTtsStarted?.();\n        this.emit(RTVIEvent.BotTtsStarted);\n      },\n      onBotTtsStopped: () => {\n        options?.callbacks?.onBotTtsStopped?.();\n        this.emit(RTVIEvent.BotTtsStopped);\n      },\n    };\n\n    // Update options to reference wrapped callbacks and config defaults\n    this._options = {\n      ...options,\n      callbacks: wrappedCallbacks,\n      enableMic: options.enableMic ?? true,\n      enableCam: options.enableCam ?? false,\n      enableScreenShare: options.enableScreenShare ?? false,\n    };\n\n    // Instantiate the transport class and bind message handler\n    this._initialize();\n\n    // Get package version number\n    logger.debug(\"[Pipecat Client] Initialized\", this.version);\n  }\n\n  public setLogLevel(level: LogLevel) {\n    logger.setLevel(level);\n  }\n\n  // ------ Transport methods\n\n  /**\n   * Initialize local media devices\n   */\n  public async initDevices() {\n    logger.debug(\"[Pipecat Client] Initializing devices...\");\n    await this._transport.initDevices();\n  }\n\n  /**\n   * startBot() is a method that initiates the bot by posting to a specified endpoint\n   * that optionally returns connection parameters for establishing a transport session.\n   * @param startBotParams\n   * @returns Promise that resolves to TransportConnectionParams or unknown\n   */\n  @transportAlreadyStarted\n  public async startBot(startBotParams: APIRequest): Promise<unknown> {\n    this._transport.state = \"authenticating\";\n    this._transport.startBotParams = startBotParams\n    this._abortController = new AbortController();\n    let response: unknown;\n    try {\n      response = await makeRequest(startBotParams, this._abortController);\n    } catch (e) {\n      let errMsg = \"An unknown error occurred while starting the bot.\";\n      let status;\n      if (e instanceof Response) {\n        const errResp = await e.json();\n        errMsg = errResp.info ?? errResp.detail ?? e.statusText;\n        status = e.status;\n      } else if (e instanceof Error) {\n        errMsg = e.message;\n      }\n      this._options.callbacks?.onError?.(\n        new RTVIMessage(RTVIMessageType.ERROR_RESPONSE, {\n          message: errMsg,\n          fatal: true,\n        })\n      );\n      throw new RTVIErrors.StartBotError(errMsg, status);\n    }\n    this._transport.state = \"authenticated\";\n    this._options.callbacks?.onBotStarted?.(response);\n    return response;\n  }\n\n  /**\n   * The `connect` function establishes a transport session and awaits a\n   * bot-ready signal, handling various connection states and errors.\n   * @param {TransportConnectionParams} [connectParams] -\n   * The `connectParams` parameter in the `connect` method should be of type\n   * `TransportConnectionParams`. This parameter is passed to the transport\n   * for establishing a transport session.\n   * NOTE: `connectParams` as type `ConnectionEndpoint` IS NOW DEPRECATED. If you\n   * want to authenticate and connect to a bot in one step, use\n   * `startBotAndConnect()` instead.\n   * @returns The `connect` method returns a Promise that resolves to an unknown value.\n   */\n  @transportAlreadyStarted\n  public async connect(\n    connectParams?: TransportConnectionParams | ConnectionEndpoint\n  ): Promise<BotReadyData> {\n    if (connectParams && isAPIRequest(connectParams)) {\n      logger.warn(\n        \"Calling connect with an API endpoint is deprecated. Use startBotAndConnect() instead.\"\n      );\n      return this.startBotAndConnect(connectParams as APIRequest);\n    }\n\n    // Establish transport session and await bot ready signal\n    return new Promise((resolve, reject) => {\n      (async () => {\n        this._connectResolve = resolve;\n\n        if (this._transport.state === \"disconnected\") {\n          await this._transport.initDevices();\n        }\n\n        try {\n          await this._transport.connect(\n            connectParams as TransportConnectionParams\n          );\n          await this._transport.sendReadyMessage();\n        } catch (e) {\n          this.disconnect();\n          reject(e);\n          return;\n        }\n      })();\n    });\n  }\n\n  @transportAlreadyStarted\n  public async startBotAndConnect(\n    startBotParams: APIRequest\n  ): Promise<BotReadyData> {\n    // since startBot() will change the transport state, we need\n    // to do device initialization here.\n    if (this._transport.state === \"disconnected\") {\n      await this._transport.initDevices();\n    }\n\n    const connectionParams = await this.startBot(startBotParams);\n    return this.connect(connectionParams);\n  }\n\n  /**\n   * Disconnect the voice client from the transport\n   * Reset / reinitialize transport and abort any pending requests\n   */\n  public async disconnect(): Promise<void> {\n    await this._transport.disconnect();\n    this._messageDispatcher.disconnect();\n  }\n\n  /**\n   * The _initialize function performs internal set up of the transport and\n   * message dispatcher.\n   */\n  private _initialize() {\n    this._transport.initialize(this._options, this.handleMessage.bind(this));\n\n    // Create a new message dispatch queue for async message handling\n    this._messageDispatcher = new MessageDispatcher(\n      this._transport.sendMessage.bind(this._transport)\n    );\n  }\n\n  /**\n   * Get the current state of the transport\n   */\n  public get connected(): boolean {\n    return [\"connected\", \"ready\"].includes(this._transport.state);\n  }\n\n  public get transport(): Transport {\n    return this._transportWrapper.proxy;\n  }\n\n  public get state(): TransportState {\n    return this._transport.state;\n  }\n\n  public get version(): string {\n    return packageJson.version;\n  }\n\n  // ------ Device methods\n\n  public async getAllMics(): Promise<MediaDeviceInfo[]> {\n    return await this._transport.getAllMics();\n  }\n\n  public async getAllCams(): Promise<MediaDeviceInfo[]> {\n    return await this._transport.getAllCams();\n  }\n\n  public async getAllSpeakers(): Promise<MediaDeviceInfo[]> {\n    return await this._transport.getAllSpeakers();\n  }\n\n  public get selectedMic() {\n    return this._transport.selectedMic;\n  }\n\n  public get selectedCam() {\n    return this._transport.selectedCam;\n  }\n\n  public get selectedSpeaker() {\n    return this._transport.selectedSpeaker;\n  }\n\n  public updateMic(micId: string) {\n    this._transport.updateMic(micId);\n  }\n\n  public updateCam(camId: string) {\n    this._transport.updateCam(camId);\n  }\n\n  public updateSpeaker(speakerId: string) {\n    this._transport.updateSpeaker(speakerId);\n  }\n\n  public enableMic(enable: boolean) {\n    this._transport.enableMic(enable);\n  }\n\n  public get isMicEnabled(): boolean {\n    return this._transport.isMicEnabled;\n  }\n\n  public enableCam(enable: boolean) {\n    this._transport.enableCam(enable);\n  }\n\n  public get isCamEnabled(): boolean {\n    return this._transport.isCamEnabled;\n  }\n\n  public tracks(): Tracks {\n    return this._transport.tracks();\n  }\n\n  public enableScreenShare(enable: boolean) {\n    return this._transport.enableScreenShare(enable);\n  }\n\n  public get isSharingScreen(): boolean {\n    return this._transport.isSharingScreen;\n  }\n\n  // ------ Messages\n\n  /**\n   * Directly send a message to the bot via the transport.\n   * Do not await a response.\n   * @param msgType - a string representing the message type\n   * @param data - a dictionary of data to send with the message\n   */\n  @transportReady\n  public sendClientMessage(msgType: string, data?: unknown): void {\n    this._transport.sendMessage(\n      new RTVIMessage(RTVIMessageType.CLIENT_MESSAGE, {\n        t: msgType,\n        d: data,\n      } as ClientMessageData)\n    );\n  }\n\n  /**\n   * Directly send a message to the bot via the transport.\n   * Wait for and return the response.\n   * @param msgType - a string representing the message type\n   * @param data - a dictionary of data to send with the message\n   * @param timeout - optional timeout in milliseconds for the response\n   */\n  @transportReady\n  public async sendClientRequest(\n    msgType: string,\n    data: unknown,\n    timeout?: number\n  ) {\n    const msgData: ClientMessageData = { t: msgType, d: data };\n    const response = await this._messageDispatcher.dispatch(\n      msgData,\n      RTVIMessageType.CLIENT_MESSAGE,\n      timeout\n    );\n    const ret_data = response.data as ClientMessageData;\n    return ret_data.d;\n  }\n\n  public registerFunctionCallHandler(\n    functionName: string,\n    callback: FunctionCallCallback\n  ) {\n    this._functionCallCallbacks[functionName] = callback;\n  }\n\n  public unregisterFunctionCallHandler(functionName: string) {\n    delete this._functionCallCallbacks[functionName];\n  }\n\n  public unregisterAllFunctionCallHandlers() {\n    this._functionCallCallbacks = {};\n  }\n\n  @transportReady\n  public async appendToContext(context: LLMContextMessage) {\n    logger.warn(\"appendToContext() is deprecated. Use sendText() instead.\");\n    await this._transport.sendMessage(\n      new RTVIMessage(RTVIMessageType.APPEND_TO_CONTEXT, {\n        role: context.role,\n        content: context.content,\n        run_immediately: context.run_immediately,\n      } as LLMContextMessage)\n    );\n    return true;\n  }\n\n  @transportReady\n  public async sendText(content: string, options: SendTextOptions = {}) {\n    await this._transport.sendMessage(\n      new RTVIMessage(RTVIMessageType.SEND_TEXT, {\n        content,\n        options,\n      })\n    );\n  }\n\n  /**\n   * Disconnects the bot, but keeps the session alive\n   */\n  @transportReady\n  public disconnectBot(): void {\n    this._transport.sendMessage(\n      new RTVIMessage(RTVIMessageType.DISCONNECT_BOT, {})\n    );\n  }\n\n  protected handleMessage(ev: RTVIMessage): void {\n    logger.debug(\"[RTVI Message]\", ev);\n\n    switch (ev.type) {\n      case RTVIMessageType.BOT_READY: {\n        const data = ev.data as BotReadyData;\n        const botVersion = data.version\n          ? data.version.split(\".\").map(Number)\n          : [0, 0, 0];\n        logger.debug(`[Pipecat Client] Bot is ready. Version: ${data.version}`);\n        if (botVersion[0] < 1) {\n          logger.warn(\n            \"[Pipecat Client] Bot version is less than 1.0.0, which may not be compatible with this client.\"\n          );\n        }\n        this._connectResolve?.(ev.data as BotReadyData);\n        this._options.callbacks?.onBotReady?.(ev.data as BotReadyData);\n        break;\n      }\n      case RTVIMessageType.ERROR:\n        this._options.callbacks?.onError?.(ev);\n        break;\n      case RTVIMessageType.SERVER_RESPONSE: {\n        this._messageDispatcher.resolve(ev);\n        break;\n      }\n      case RTVIMessageType.ERROR_RESPONSE: {\n        const resp = this._messageDispatcher.reject(ev);\n        this._options.callbacks?.onMessageError?.(resp as RTVIMessage);\n        break;\n      }\n      case RTVIMessageType.USER_STARTED_SPEAKING:\n        this._options.callbacks?.onUserStartedSpeaking?.();\n        break;\n      case RTVIMessageType.USER_STOPPED_SPEAKING:\n        this._options.callbacks?.onUserStoppedSpeaking?.();\n        break;\n      case RTVIMessageType.BOT_STARTED_SPEAKING:\n        this._options.callbacks?.onBotStartedSpeaking?.();\n        break;\n      case RTVIMessageType.BOT_STOPPED_SPEAKING:\n        this._options.callbacks?.onBotStoppedSpeaking?.();\n        break;\n      case RTVIMessageType.USER_TRANSCRIPTION: {\n        const TranscriptData = ev.data as TranscriptData;\n        this._options.callbacks?.onUserTranscript?.(TranscriptData);\n        break;\n      }\n      case RTVIMessageType.BOT_TRANSCRIPTION: {\n        this._options.callbacks?.onBotTranscript?.(ev.data as BotLLMTextData);\n        break;\n      }\n      case RTVIMessageType.BOT_LLM_TEXT:\n        this._options.callbacks?.onBotLlmText?.(ev.data as BotLLMTextData);\n        break;\n      case RTVIMessageType.BOT_LLM_STARTED:\n        this._options.callbacks?.onBotLlmStarted?.();\n        break;\n      case RTVIMessageType.BOT_LLM_STOPPED:\n        this._options.callbacks?.onBotLlmStopped?.();\n        break;\n      case RTVIMessageType.BOT_TTS_TEXT:\n        this._options.callbacks?.onBotTtsText?.(ev.data as BotTTSTextData);\n        break;\n      case RTVIMessageType.BOT_TTS_STARTED:\n        this._options.callbacks?.onBotTtsStarted?.();\n        break;\n      case RTVIMessageType.BOT_TTS_STOPPED:\n        this._options.callbacks?.onBotTtsStopped?.();\n        break;\n      case RTVIMessageType.METRICS:\n        this._options.callbacks?.onMetrics?.(ev.data as PipecatMetricsData);\n        this.emit(RTVIEvent.Metrics, ev.data as PipecatMetricsData);\n        break;\n      case RTVIMessageType.SERVER_MESSAGE: {\n        this._options.callbacks?.onServerMessage?.(ev.data);\n        this.emit(RTVIEvent.ServerMessage, ev.data);\n        break;\n      }\n      case RTVIMessageType.LLM_FUNCTION_CALL: {\n        const data = ev.data as LLMFunctionCallData;\n        // First check if there's a registered function call handler\n        // and trigger it if so.\n        const fc = this._functionCallCallbacks[data.function_name];\n        if (fc) {\n          const params = {\n            functionName: data.function_name,\n            arguments: data.args,\n          };\n          /*\n           * registered function call handlers have the ability to\n           * asynchronously return a result that is sent back to the server\n           * as an automatically crafted LLM_FUNCTION_CALL_RESULT message.\n           * Note: If the callback returns null or undefined, no result message\n           * is sent.\n           */\n          fc(params).then((result) => {\n            // == intentional to check for null or undefined\n            if (result == undefined) {\n              return;\n            }\n            this._transport.sendMessage(\n              new RTVIMessage(RTVIMessageType.LLM_FUNCTION_CALL_RESULT, {\n                function_name: data.function_name,\n                tool_call_id: data.tool_call_id,\n                arguments: data.args,\n                result,\n              })\n            );\n          });\n        }\n        /*\n         * Now emit the event for any generic LLMFunctionCall listeners/callbacks\n         * Note: When using these, the onus is on the client to generate and\n         *       send the LLM_FUNCTION_CALL_RESULT message if needed.\n         */\n        this._options.callbacks?.onLLMFunctionCall?.(data);\n        this.emit(RTVIEvent.LLMFunctionCall, data);\n        break;\n      }\n      case RTVIMessageType.BOT_LLM_SEARCH_RESPONSE: {\n        const data = ev.data as BotLLMSearchResponseData;\n        this._options.callbacks?.onBotLlmSearchResponse?.(data);\n        this.emit(RTVIEvent.BotLlmSearchResponse, data);\n        break;\n      }\n      default: {\n        logger.debug(\"[Pipecat Client] Unrecognized message type\", ev.type);\n        break;\n      }\n    }\n  }\n\n  // ------ Helpers\n}\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nexport * from \"./client\";\nexport * from \"./dispatcher\";\nexport * from \"./logger\";\nexport * from \"./rest_helpers\";\nexport * from \"./transport\";\nexport * from \"./utils\";\n","/**\n * Copyright (c) 2024, Daily.\n *\n * SPDX-License-Identifier: BSD-2-Clause\n */\n\nexport * from \"./client\";\nexport * from \"./rtvi\";\n"],"names":[],"version":3,"file":"index.d.ts.map"}